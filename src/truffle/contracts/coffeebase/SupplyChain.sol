// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.24;


import "../coffeeaccesscontrol/ConsumerRole.sol";
import "../coffeeaccesscontrol/DistributorRole.sol";
import "../coffeeaccesscontrol/FarmerRole.sol";
import "../coffeeaccesscontrol/RetailerRole.sol";


// Define a contract 'Supplychain'
contract SupplyChain is FarmerRole, DistributorRole, RetailerRole, ConsumerRole  {

  // Define 'owner'
  address owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;
  
  // Define enum 'State' with the following values:
  enum State 
  { 
    Harvested,  // 0
    Processed,  // 1
    Packed,     // 2
    ForSale,    // 3
    Sold,       // 4
    Shipped,    // 5
    Received,   // 6
    Purchased   // 7
    }

  State constant defaultState = State.Harvested;

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address payable  originFarmerID; // Metamask-Ethereum address of the Farmer
    string  originFarmName; // Farmer Name
    string  originFarmInformation;  // Farmer Information
    string  originFarmLatitude; // Farm Latitude
    string  originFarmLongitude;  // Farm Longitude
    uint    productID;  // Product ID potentially a combination of upc + sku
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    State   itemState;  // Product State as represented in the enum above
    address payable  distributorID;  // Metamask-Ethereum address of the Distributor
    address payable  retailerID; // Metamask-Ethereum address of the Retailer
    address payable  consumerID; // Metamask-Ethereum address of the Consumer
  }


// -------------- optional ----------------

// so this is optional, i want to allow farmers store ipfs hash also

  struct Harvest {
    uint upc;
    string imageIpfsHash;
  }

  mapping(uint => Harvest) private harvests; //so this is a mapping upc to Harvest struct

  //Event to log when an image is uploaded
  event ImageUploaded(uint upc, string imageIpfsHash);

  // Function to allow the farmer to upload an image and associate it with a UPC, just paste in the ipfs hash
  function upload(uint  _upc, string memory _imageIpfsHash) public onlyFarmer verifyCaller(msg.sender) {
    require(bytes(harvests[_upc].imageIpfsHash).length == 0, "Ipfs hash already uploaded for this upc");

  //create a new harvest staruct
    Harvest memory newHarvest = Harvest({
      upc: _upc,
      imageIpfsHash: _imageIpfsHash
    });

  harvests[_upc] = newHarvest; //set the mapping

  //emit the event
  emit ImageUploaded(_upc, _imageIpfsHash);

  }

  // Function to read the image IPFS hash associated with a UPC
    function read(uint  _upc) public view returns (string memory) {
        return harvests[_upc].imageIpfsHash;
    }

// -------------- optional ----------------


  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Harvested(uint upc);
  event Processed(uint upc);
  event Packed(uint upc);
  event ForSale(uint upc);
  event Sold(uint upc);
  event Shipped(uint upc);
  event Received(uint upc);
  event Purchased(uint upc);

   // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() virtual  {
    require(msg.sender == owner, "only owner can call this");
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address, "you are not allowed to perform this operation"); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) { 
    require(msg.value >= _price, "amount sent is not enough"); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  // Define a modifier that checks the price and refunds the remaining balance
modifier checkValue(uint _upc, string memory mode) {
    _; // Run the function first, then proceed to run the contents of the modifier

    uint _price = items[_upc].productPrice; // Price of the item
    uint amountToReturn = msg.value - _price; // Amount to send back if the amount sent in is more than the product price

    // payable(msg.sender).transfer(amountToReturn);

    if (keccak256(abi.encodePacked(mode)) == keccak256(abi.encodePacked("buyItem"))) {
        items[_upc].distributorID.transfer(amountToReturn);
    } else if (keccak256(abi.encodePacked(mode)) == keccak256(abi.encodePacked("purchaseItem"))) {
        items[_upc].consumerID.transfer(amountToReturn); // Send change to the final consumer back
    }
}

   // Define a modifier that checks if an item.state of a upc is Harvested
  modifier harvested(uint _upc) {
    require(items[_upc].itemState == State.Harvested, "Item has to be harvested");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Processed
  modifier processed(uint _upc) {
    require(items[_upc].itemState == State.Processed, "Item has to be processed");
    _;
  }
  
   // Define a modifier that checks if an item.state of a upc is Packed
  modifier packed(uint _upc) {
    require(items[_upc].itemState == State.Packed, "Item has to be packed");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is ForSale
  modifier forSale(uint _upc) {
    require(items[_upc].itemState == State.ForSale, "Item has to be for sale");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Sold
  modifier sold(uint _upc) {
    require(items[_upc].itemState == State.Sold, "Item has to be sold");
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Shipped
  modifier shipped(uint _upc) {
    require(items[_upc].itemState == State.Shipped, "Item has to be shipped");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Received
  modifier received(uint _upc) {
    require(items[_upc].itemState == State.Received, "Item has to be received");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Purchased
  modifier purchased(uint _upc) {
    require(items[_upc].itemState == State.Purchased, "Item has to be purchased");
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() payable {
    owner = msg.sender;
    sku = 1;
    upc = 1;
  }

   // Define a function 'kill' if required
  function kill() public payable  onlyOwner {
    if (msg.sender == owner) {
      payable(owner).transfer(address(this).balance); // Send the balance of the contract to the owner
    }
  }

   // Define a function 'harvestItem' that allows a farmer to mark an item 'Harvested'
  function harvestItem(uint _upc, address payable _originFarmerID, string memory _originFarmName, string memory _originFarmInformation, string memory  _originFarmLatitude, string memory  _originFarmLongitude, string memory  _productNotes) public onlyFarmer {
     // Increment sku
    sku = sku + 1;
    // Add the new item as part of Harvest
    Item memory newItem = Item({
        sku: sku,
        upc: _upc,
        ownerID: address(0), //this can be the msg.sender, so as to make sure other farmers cant process, pack, or put for sale other farmers goods, but this app doesnt check for that, so all farmers can help other farmers change the state of their goods
        originFarmerID: _originFarmerID,
        originFarmName: _originFarmName,
        originFarmInformation: _originFarmInformation,
        originFarmLatitude: _originFarmLatitude,
        originFarmLongitude: _originFarmLongitude,
        productNotes: _productNotes,
        distributorID: payable(address(0)),
        retailerID: payable(address(0)),
        consumerID: payable(address(0)),
        productID: _upc + sku,
        productPrice: 0,
        itemState: State.Harvested
    });
   
    // Emit the appropriate event
    emit Harvested(_upc);

    items[_upc] = newItem;
  }

  // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
  function processItem(uint _upc) public harvested(_upc) verifyCaller(msg.sender) onlyFarmer  { //before its processed it should be in harvestetd state
  // Call modifier to check if upc has passed previous supply chain stage
  
  // Call modifier to verify caller of this function
  
    // Update the appropriate fields
    items[_upc].itemState = State.Processed;
    
    // Emit the appropriate event
    emit Processed(_upc);
    
  }

  // Define a function 'packItem' that allows a farmer to mark an item 'Packed'
  function packItem(uint _upc) public processed(_upc) verifyCaller(msg.sender) onlyFarmer  {
  // Call modifier to check if upc has passed previous supply chain stage
  
  // Call modifier to verify caller of this function
  
    // Update the appropriate fields
    items[_upc].itemState = State.Packed;
    
    // Emit the appropriate event
    emit Packed(_upc);
    
  }

  // Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'
  function sellItem(uint _upc, uint _price) public packed(_upc) verifyCaller(msg.sender) onlyFarmer {
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifier to verify caller of this function
  
    // Update the appropriate fields
    items[_upc].itemState = State.ForSale;
    items[_upc].productPrice = _price;
    
    // Emit the appropriate event
    emit ForSale(_upc);
    
  }

  // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyItem(uint _upc) public payable forSale(_upc)
   paidEnough(msg.value) 
  checkValue(_upc, "buyItem")
   onlyDistributor {
    // Call modifier to check if upc has passed previous supply chain stage
    // Call modifer to check if buyer has paid enough
    // Call modifer to send any excess ether back to buyer
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    items[_upc].ownerID = payable(msg.sender);
    items[_upc].distributorID = payable(msg.sender);
    items[_upc].itemState = State.Sold;
    
    // Transfer money to farmer
    items[_upc].originFarmerID.transfer(msg.value);
    
    // emit the appropriate event
    emit Sold(_upc);
  }

  // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
  // Use the above modifers to check if the item is sold
  function shipItem(uint _upc) public sold(_upc) verifyCaller(msg.sender) onlyDistributor {
    // Call modifier to check if upc has passed previous supply chain stage
    // Call modifier to verify caller of this function
    // Update the appropriate fields
    items[_upc].itemState = State.Shipped;
    
    // Emit the appropriate event
    emit Shipped(_upc);
    
  }

  // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
  // Use the above modifiers to check if the item is shipped
  function receiveItem(uint _upc) public shipped(_upc) onlyRetailer {
    // Call modifier to check if upc has passed previous supply chain stage
    
    // Access Control List enforced by calling Smart Contract / DApp
    
    // Update the appropriate fields - ownerID, retailerID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].retailerID = payable(msg.sender);
    items[_upc].itemState = State.Received;
    
    // Emit the appropriate event
    emit Received(_upc);
    
  }

    // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
  // Use the above modifiers to check if the item is received
  function purchaseItem(uint _upc) public payable  received(_upc) paidEnough(msg.value) onlyConsumer checkValue(_upc, "purchaseItem") {
    // Call modifier to check if upc has passed previous supply chain stage
    // Access Control List enforced by calling Smart Contract / DApp

    // Update the appropriate fields - ownerID, consumerID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].consumerID = payable(msg.sender);
    items[_upc].itemState = State.Purchased;

    //send money to retailer
    items[_upc].retailerID.transfer(msg.value);
    
    // Emit the appropriate event
    emit Purchased(_upc);
    
  }

  // Define a function 'fetchItemBufferOne' that fetches the data
  function fetchItemBufferOne(uint _upc) public view returns (
  uint  itemSKU,
  uint itemUPC,
  address ownerID,
  address originFarmerID,
  string memory  originFarmName,
  string memory originFarmInformation,
  string memory originFarmLatitude,
  string memory  originFarmLongitude) {
  // Assign values to the 8 parameters
  Item memory item = items[_upc];
    
  return (
    item.sku,  // Use item.sku instead of itemSKU
    item.upc,
    item.ownerID,
    item.originFarmerID,
    item.originFarmName,
    item.originFarmInformation,
    item.originFarmLatitude,
    item.originFarmLongitude
   );
  }

  // Define a function 'fetchItemBufferTwo' that fetches the data
  function fetchItemBufferTwo(uint _upc) public view returns (
  uint    itemSKU,
  uint    itemUPC,
  uint    productID,
  string memory  productNotes,
  uint    productPrice,
  uint    itemState,
  address distributorID,
  address retailerID,
  address consumerID
  ) {
    // Assign values to the 9 parameters
   Item memory item = items[_upc];
    
  return (
    item.sku,
    item.upc,
    item.productID,
    item.productNotes,
    item.productPrice,
    uint(item.itemState),  // Convert the enum to uint if needed
    item.distributorID,
    item.retailerID,
    item.consumerID
  );
  }
}